# Virgil Demo Chat

In this guide weâ€™ll create a basic chat application using **Virgil** technologies stack for end-to-end encryption.

- [Introduction](#introduction)
- [Install](#install)
- [Getting Started](#getting-started)
- [Predefined parameters](#predefined-parameters)
- [Register user](#register-user)
- [Login](#login)
- [Initialize main activity](#init)
- [Working with Channels](#channels)
- [Working with Users](#users)
- [Chat](#chat)
- [See also](#see-also)

## Introduction

This application is an example of how to create a secure IP-messaging Android application using Virgil Services as a security layer.

## Install
 
To be able to run the application code you need to install [Android Studio](https://developer.android.com/studio/index.html):
 
## Getting Started

In a Virgil Demo Chat application, *a Channel* is where all the action happens. Whether it's between two users or two hundred, *the Channel* is where *Messages* are sent, received, and archived for later viewing by offline clients.

## Predefined parameters

The first thing we need to do is grab all the necessary information from our Virgil Dev [account](https://developer.virgilsecurity.com/dashboard/).

| Parameter Name                  | Description                    |
|---------------------------------|--------------------------------|
| base_url                        | The URL of Virgil Demo Chat server |
| virgil_app_id                   | The APP_ID uniquely identifies your application in our services, it is also used to identify the Public key generated in a pair with `appKey` |
| virgil_app_private_key          | Base64 encoding of Private Key(*.virgilkey), you generated while creating your application |
| virgil_app_private_key_password | The application's Private Key password. |
| virgil_token                    | The access token provides authenticated secure access to Virgil Keys Services and is passed with each API call. |

## Register user

When App starts first and user enters a nickname and presses 'Connect' button the application should register new user on server.

```java
# LoginActivity

KeyPair keyPair = crypto.generateKeys();
publicKey = keyPair.getPublicKey();
privateKey = keyPair.getPrivateKey();

// Register chat member
chatService.register(nickname, publicKey, privateKey);
```

```java
# ChatClient

CreateCardRequest request = new CreateCardRequest(nickname, ApplicationConstants.IDENTITY_TYPE, mCrypto.exportPublicKey(publicKey));
RequestSigner requestSigner = new RequestSigner(mCrypto);
requestSigner.selfSign(request, privateKey);

final JsonObject json = new JsonObject();
String exportedRequest = request.exportRequest();

json.addProperty("card_request", exportedRequest);

...
String body = doPost("/users/register", json.toString());
mToken = ConvertionUtils.getGson().fromJson(body, Token.class).getToken();
```

If user registered successfully, the App should save authentication token (mToken) for future use. This token is used for authentication and should be added to each request.

## Login

If user already registered from this device, App should login user and obtain authentication token.

```java
# ChatClient

final JsonObject json = new JsonObject();
json.addProperty("username", nickname);

...
String body = doPost("/users/login", json.toString());
mToken = ConvertionUtils.getGson().fromJson(body, Token.class).getToken();
```

## Initialize main activity

First of all App should instantiate Crypto which is used for encryption.

```java
# MainActivity

private Crypto crypto;
...
crypto = new VirgilCrypto();
```

Then user's private key which is generated during registration could be loaded from preferences. Private key used for message decryption and signing.

```java
PrivateKey privateKey = crypto.importPrivateKey(ConvertionUtils.base64ToArray(PrefsUtils.getInstance().getString(ApplicationConstants.Prefs.PRIVATE_KEY)));
```

When private key loaded, App can instantiate ChatService.

```java
# MainActivity

ChatService chatService;

...
chatService = new ChatService(crypto, token);
chatService.setPrivateKey(privateKey);
```

The token is authentication token obtained during login or registration.

## Working with Channels

### Get list of channels available for current user

```java
# ChatClient

String body = doGet("/channels");
RestChannel[] restChannels = ConvertionUtils.getGson().fromJson(body, RestChannel[].class);
```

### Get channel by ID

```java
# ChatClient

String body = doGet("/channels/" + URLEncoder.encode(channelId, "UTF-8"));
Channel channel = ConvertionUtils.getGson().fromJson(body, Channel.class);
```

### Create new channel

All messages in channel encrypted with channel public key. Thus, you need channel private key to decrypt channel messages.
This key generated by channel owner when channel created. Other channel members obtain channel private key from owner or other channel member. This private key shouldn't be stored outside chat application due to security reason.

```java
# ChatService

KeyPair keyPair = mCrypto.generateKeys();
mChatClient.createChannel(channelName, keyPair.getPublicKey(), keyPair.getPrivateKey());
```

```java
# ChatClient

CreateCardRequest request = new CreateCardRequest(channelName, ApplicationConstants.IDENTITY_TYPE, mCrypto.exportPublicKey(publicKey));
RequestSigner requestSigner = new RequestSigner(mCrypto);
requestSigner.selfSign(request, privateKey);

final JsonObject json = new JsonObject();
json.addProperty("card_request", request.exportRequest());

String body = doPost("/channels", json.toString());
RestChannel restChannel = ConvertionUtils.getGson().fromJson(body, RestChannel.class);
Channel channel = Converter.fromRestChannel(restChannel);
channel.setPrivateKey(privateKey);
```

Channel private key should be saved for future use.

## Working with Users

### Search

You can find active users to join them to channel.

```java
# ChatClient

String body = doGet("/users/search?query=" + URLEncoder.encode(name, "UTF-8"));
Member[] users = ConvertionUtils.getGson().fromJson(body, Member[].class);
```

## Chat

It is assumed you're using [socket.io](http://socket.io) for socket communication.

### Create socket

```java
# ChatClient

private Socket mSocket;

...
mSocket = IO.socket(mBaseUrl);
```

### Authentication

```java
# ChatClient

mSocket.on(Socket.EVENT_CONNECT, new Emitter.Listener() {
    @Override
    public void call(Object... args) {
        Log.d(TAG, "Connected to websocket");
        JSONObject token = new JSONObject();
        try {
            token.put("token", mToken);
        } catch (JSONException e) {
        }
        Log.d(TAG, "Trying to authorize: " + token);
        mSocket.emit("authenticate", token)
            .on("authenticated", new Emitter.Listener() {
                @Override
                public void call(Object... args) {
                    Log.d(TAG, "Authenticated");
                    ...
                }
            })
            .on("unauthorized", new Emitter.Listener() {
                @Override
                public void call(Object... args) {
                    Log.d(TAG, "Unauthorized");
                    ...
                }
            });
    }
});
```

### Using channels

#### Add new members

You can add users as members to the channel.

```java
# ChatClient

public void addMembers(String channelId, String channelKey, List<String> memberIds) {
    JSONObject json = new JSONObject();
    try {
        json.put("channelId", channelId);
        json.put("channelKey", channelKey);

        JSONArray memberIdsArray = new JSONArray();
        json.put("memberIds", memberIdsArray);
        for (String member : memberIds) {
            memberIdsArray.put(member);
        }
        Log.d(TAG, "Add members: " + json.toString());
    } catch (JSONException e) {
        Log.e(TAG, "addMemeber", e);
    }
    mSocket.emit("add members", json);
}
```

where
- channelId is channel identifier.
- channelKey is Base64-encoded channel private key.
- memberIds list of users invited into the channel.

User, added to the channel receives correspond message.

```java
# ChatClient

mSocket.on("added to channel", new Emitter.Listener() {
    @Override
    public void call(Object... args) {
        Log.d(TAG, "Added to channel: " + args[0]);
        ChatChannel channel = ConvertionUtils.getGson().fromJson(String.valueOf(args[0]), ChatChannel.class);
        ...
    }
});
```

#### Join

When user added to the channel, he can join this channel.

```java
# ChatClient

JSONObject json = new JSONObject();
try {
    json.put("channelId", channelId);
} catch (JSONException e) {
}
mSocket.emit("join channel", json);
```

After that user is able to send\receive messages to\from a channel.

#### Leave

User can also leave the channel he've joined to stop receiving messages from it.

```java
# ChatClient

JSONObject json = new JSONObject();
try {
    json.put("channelId", channelId);
} catch (JSONException e) {
}
mSocket.emit("leave channel", new Object[]{json}, new Ack() {
    @Override
    public void call(Object... args) {
        Log.d(TAG, "Leave channel ACK " + args[0].toString());
    }
});
```

#### Sending messages

Before message could be sent to channel, it should be encrypted with channel public key.
```java
# ChatService

private String encryptMessage(String channelId, String message) {
    // Encrypt message with channel public key
    Channel channel = mChannels.get(channelId);
    ...
    if (channel.isPublic()) {
        // No encryption for public channel
        return ConvertionUtils.toBase64String(message);
    }
    byte[] encryptedData = mCrypto.encrypt(ConvertionUtils.toBytes(message), channel.getPublicKey());
    return ConvertionUtils.toBase64String(encryptedData);
}
```
After that message could be posted to the channel.

```java
# ChatClient

public void postMessage(String channelId, String message) {
    Log.d(TAG, "Post message to channel: " + channelId);
    JSONObject json = new JSONObject();
    try {
        json.put("channelId", channelId);
        json.put("body", message);
    } catch (JSONException e) {
        Log.e(TAG, "Can't build post message request", e);
    }
    mSocket.emit("post message", json);
}
```

All users joined to the channel receives message.

```java
# ChatClient

mSocket.on("message posted", new Emitter.Listener() {
    @Override
    public void call(Object... args) {
        Log.d(TAG, "Message posted: " + args);
        Message message = ConvertionUtils.getGson().fromJson(String.valueOf(args[0]), Message.class);
        ...        
});
```

### Get messages from particular channel

When user joined to the channel, he can read latest messages from the channel.

```java
# ChatClient

String body = doGet("/channels/" + URLEncoder.encode(channelId, "UTF-8") + "/messages");
Message[] messages = ConvertionUtils.getGson().fromJson(body, Message[].class);
```

## See also

* [Virgil Quickstart](https://github.com/VirgilSecurity/virgil-sdk-x/blob/v3/Docs/quickstart.md)
* [Tutorial Virgil Foundation](https://github.com/VirgilSecurity/virgil-foundation-x/blob/master/README.md)
* [Tutorial Virgil SDK](https://github.com/VirgilSecurity/virgil-sdk-x/blob/v3/Docs/tutorial-sdk.md)
* [Virgil SDK API Reference](http://virgilsecurity.github.io/virgil-sdk-x/)
